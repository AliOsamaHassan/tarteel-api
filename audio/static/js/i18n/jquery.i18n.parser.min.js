/*!
 * jQuery Internationalization library
 *
 * Copyright (C) 2011-2013 Santhosh Thottingal, Neil Kandalgaonkar
 *
 * jquery.i18n is dual licensed GPLv2 or later and MIT. You don't have to do
 * anything special to choose one license or the other and you don't have to
 * notify anyone which license you are using. You are free to use
 * UniversalLanguageSelector in commercial projects as long as the copyright
 * header is left intact. See files GPL-LICENSE and MIT-LICENSE for details.
 *
 * @licence GNU General Public Licence 2.0 or later
 * @licence MIT License
 */(function(a){'use strict';var b=function(b){this.options=a.extend({},a.i18n.parser.defaults,b),this.language=a.i18n.languages[String.locale]||a.i18n.languages['default'],this.emitter=a.i18n.parser.emitter};b.prototype={constructor:b,simpleParse:function(a,b){return a.replace(/\$(\d+)/g,function(a,c){var d=parseInt(c,10)-1;return b[d]===void 0?'$'+c:b[d]})},parse:function(b,c){return 0>b.indexOf('{{')?this.simpleParse(b,c):(this.emitter.language=a.i18n.languages[a.i18n().locale]||a.i18n.languages['default'],this.emitter.emit(this.ast(b),c))},ast:function(a){// Try parsers until one works, if none work return null
function b(a){return function(){var b,c;for(b=0;b<a.length;b++)if(c=a[b](),null!==c)return c;return null}}// Try several parserSyntax-es in a row.
// All must succeed; otherwise, return null.
// This is the only eager one.
function c(a){var b,c,d=H,e=[];for(b=0;b<a.length;b++){if(c=a[b](),null===c)return H=d,null;e.push(c)}return e}// Run the same parser over and over until it fails.
// Must succeed a minimum of n times; otherwise, return null.
function d(a,b){return function(){for(var c=H,d=[],e=b();null!==e;)d.push(e),e=b();return d.length<a?(H=c,null):d}}// Helpers -- just make parserSyntax out of simpler JS builtin types
function e(b){var c=b.length;return function(){var d=null;return a.slice(H,H+c)===b&&(d=b,H+=c),d}}function f(b){return function(){var c=a.slice(H).match(b);return null===c?null:(H+=c[0].length,c[0])}}// There is a general pattern:
// parse a thing;
// if it worked, apply transform,
// otherwise return null.
// But using this as a combinator seems to cause problems
// when combined with nOrMore().
// May be some scoping issue.
// Used to define "literals" within template parameters. The pipe
// character is the parameter delimeter, so by default
// it is not a literal in the parameter
function g(){var a=d(1,y)();return null===a?null:a.join('')}function h(){var a=d(1,z)();return null===a?null:a.join('')}function i(){var a=c([r,s]);return null===a?null:a[1]}function j(){var a=c([t,u]);return null===a?null:['REPLACE',parseInt(a[1],10)-1]}function k(){var a,b=c([p,d(0,F)]);return null===b?null:(a=b[1],1<a.length?['CONCAT'].concat(a):a[0]);// use a "CONCAT" operator if there are multiple nodes,
// otherwise return the first node, raw.
}function l(){var a=c([B,q,j]);return null===a?null:[a[0],a[2]]}function m(){var a=c([B,q,F]);return null===a?null:[a[0],a[2]]}function n(){var a=c([C,A,D]);return null===a?null:a[1]}function o(){var a=d(0,E)();return null===a?null:['CONCAT'].concat(a)}var p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H=0;/*
			 * For success, the pos must have gotten to the end of the input
			 * and returned a non-null.
			 * n.b. This is part of language infrastructure, so we do not throw an
			 * internationalizable message.
			 */if(p=e('|'),q=e(':'),r=e('\\'),s=f(/^./),t=e('$'),u=f(/^\d+/),v=f(/^[^{}[\]$\\]/),w=f(/^[^{}[\]$\\|]/),x=f(/^[^{}[\]$\s]/),b([i,x]),y=b([i,w]),z=b([i,v]),B=function(a,b){return function(){var c=a();return null===c?null:b(c)}}(// see $wgLegalTitleChars
// not allowing : due to the need to catch "PLURAL:$1"
f(/^[ !"$&'()*,./0-9;=?@A-Z^_`a-z~\x80-\xFF+-]+/),function(a){return a.toString()}),A=b([function(){var a=c([// templates can have placeholders for dynamic
// replacement eg: {{PLURAL:$1|one car|$1 cars}}
// or no placeholders eg:
// {{GRAMMAR:genitive|{{SITENAME}}}
b([l,m]),d(0,k)]);return null===a?null:a[0].concat(a[1])},function(){var a=c([B,d(0,k)]);return null===a?null:[a[0]].concat(a[1])}]),C=e('{{'),D=e('}}'),E=b([n,j,h]),F=b([n,j,g]),G=o(),null===G||H!==a.length)throw new Error('Parse error at position '+H.toString()+' in input: '+a);return G}},a.extend(a.i18n.parser,new b)})(jQuery);
