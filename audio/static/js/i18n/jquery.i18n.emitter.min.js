/*!
 * jQuery Internationalization library
 *
 * Copyright (C) 2011-2013 Santhosh Thottingal, Neil Kandalgaonkar
 *
 * jquery.i18n is dual licensed GPLv2 or later and MIT. You don't have to do
 * anything special to choose one license or the other and you don't have to
 * notify anyone which license you are using. You are free to use
 * UniversalLanguageSelector in commercial projects as long as the copyright
 * header is left intact. See files GPL-LICENSE and MIT-LICENSE for details.
 *
 * @licence GNU General Public Licence 2.0 or later
 * @licence MIT License
 */(function(a){'use strict';var b=function(){this.language=a.i18n.languages[String.locale]||a.i18n.languages['default']};b.prototype={constructor:b,/**
		 * (We put this method definition here, and not in prototype, to make
		 * sure it's not overwritten by any magic.) Walk entire node structure,
		 * applying replacements and template functions when appropriate
		 *
		 * @param {Mixed} node abstract syntax tree (top node or subnode)
		 * @param {Array} replacements for $1, $2, ... $n
		 * @return {Mixed} single-string node or array of nodes suitable for
		 *  jQuery appending.
		 */emit:function(b,c){var d,e,f,g=this;switch(typeof b){case'string':case'number':d=b;break;case'object':if(e=a.map(b.slice(1),function(a){return g.emit(a,c)}),f=b[0].toLowerCase(),'function'==typeof g[f])d=g[f](e,c);else throw new Error('unknown operation "'+f+'"');break;case'undefined':d='';break;default:throw new Error('unexpected type in AST: '+typeof b);}return d},/**
		 * Parsing has been applied depth-first we can assume that all nodes
		 * here are single nodes Must return a single node to parents -- a
		 * jQuery with synthetic span However, unwrap any other synthetic spans
		 * in our children and pass them upwards
		 *
		 * @param {Array} nodes Mixed, some single nodes, some arrays of nodes.
		 * @return {string}
		 */concat:function(b){var c='';return a.each(b,function(a,b){c+=b}),c},/**
		 * Return escaped replacement of correct index, or string if
		 * unavailable. Note that we expect the parsed parameter to be
		 * zero-based. i.e. $1 should have become [ 0 ]. if the specified
		 * parameter is not found return the same string (e.g. "$99" ->
		 * parameter 98 -> not found -> return "$99" ) TODO throw error if
		 * nodes.length > 1 ?
		 *
		 * @param {Array} nodes One element, integer, n >= 0
		 * @param {Array} replacements for $1, $2, ... $n
		 * @return {string} replacement
		 */replace:function(a,b){var c=parseInt(a[0],10);return c<b.length?b[c]:'$'+(c+1)},/**
		 * Transform parsed structure into pluralization n.b. The first node may
		 * be a non-integer (for instance, a string representing an Arabic
		 * number). So convert it back with the current language's
		 * convertNumber.
		 *
		 * @param {Array} nodes List [ {String|Number}, {String}, {String} ... ]
		 * @return {string} selected pluralized form according to current
		 *  language.
		 */plural:function(a){var b=parseFloat(this.language.convertNumber(a[0],10)),c=a.slice(1);return c.length?this.language.convertPlural(b,c):''},/**
		 * Transform parsed structure into gender Usage
		 * {{gender:gender|masculine|feminine|neutral}}.
		 *
		 * @param {Array} nodes List [ {String}, {String}, {String} , {String} ]
		 * @return {string} selected gender form according to current language
		 */gender:function(a){var b=a[0],c=a.slice(1);return this.language.gender(b,c)},/**
		 * Transform parsed structure into grammar conversion. Invoked by
		 * putting {{grammar:form|word}} in a message
		 *
		 * @param {Array} nodes List [{Grammar case eg: genitive}, {String word}]
		 * @return {string} selected grammatical form according to current
		 *  language.
		 */grammar:function(a){var b=a[0],c=a[1];return c&&b&&this.language.convertGrammar(c,b)}},a.extend(a.i18n.parser.emitter,new b)})(jQuery);
